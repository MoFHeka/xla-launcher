/*
 * @copyright
 * BSD 3-Clause License, 2025, He Jia <mofhejia@163.com>
 * BSD 3-Clause License, 2023, pytorch-tpu
 */

#pragma once

#ifndef XLA_LAUNCHER_RUNTIME_XLA_UTIL_HPP_
#define XLA_LAUNCHER_RUNTIME_XLA_UTIL_HPP_

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <utility>

#include "xla/hlo/builder/xla_computation.h"
#include "xla/hlo/ir/hlo_module.h"
#include "xla/service/hlo_module_config.h"
#include "xla/shape_util.h"
#include "xla_launcher/hash.hpp"

namespace xla_launcher {
namespace runtime {
namespace util {

using hash_t = xla_launcher::hash_util::hash_t;

// Creates the HLO module which is generated by the input PB message.
absl::StatusOr<std::unique_ptr<xla::HloModule>> CreateModuleFromProto(
  const xla::HloModuleProto& proto,
  const xla::DebugOptions& debug_options = xla::DebugOptions());

absl::StatusOr<std::string> GetDeterministicSerializedModuleProto(
  const xla::HloModuleProto& proto);

void ReportComputationError(
  const std::string& status_str,
  absl::Span<const xla::XlaComputation* const> computations,
  absl::Span<const xla::Shape* const> output_shapes);

hash_t ShapeHash(const xla::Shape& shape);

// Namespace forwarding for hash utility functions
using xla_launcher::hash_util::ContainerHash;
using xla_launcher::hash_util::DataHash;
using xla_launcher::hash_util::Hash;
using xla_launcher::hash_util::HashCombine;
using xla_launcher::hash_util::MHash;
using xla_launcher::hash_util::StringHash;

// Return the serialized module proto, using deterministic proto serialization.
// It ensures consistent ordering of Map fields and repeated elements during
// serialization.
absl::StatusOr<std::string> GetDeterministicSerializedModuleProto(
  const xla::HloModuleProto& hlo_proto);

namespace internal {
// ExtractStatusOrValue<U>::type is T if U is absl::StatusOr<T>, and is
// undefined otherwise.
template <typename U>
struct ExtractStatusOrValue;
template <typename T>
struct ExtractStatusOrValue<absl::StatusOr<T>> {
  using type = T;
};
}  // namespace internal

// RaiseValueErrorOnFailure(func) requires `func` to be a functor that
// takes no argument and returns an absl::StatusOr<T>. It's a wrapper of
// `func()` that translates any failure in `func()` to a Python ValueError
// exception. In particular:
//
//   - if `func()` returns an error, throws an std::invalid_argument,
//     which is translated to a Python ValueError exception;
//     (https://pybind11.readthedocs.io/en/stable/advanced/exceptions.html).
//   - if `func()` throws any exception, rethrows it as an
//     std::invalid_argument so that we get a Python ValueError;
//   - if `func()` successfully returns a value of type T, returns the value;
//   - however, if `func()` crashes (e.g. due to a CHECK), we cannot
//     catch it; therefore we should ensure that `func()` never
//     crashes (and fix any crash as a bug).
template <typename Func>
typename internal::ExtractStatusOrValue<decltype(std::declval<Func>()())>::type
RaiseValueErrorOnFailure(const Func& func) {
  decltype(std::declval<Func>()()) result;
  try {
    result = func();
  } catch (const std::exception& e) {
    throw std::invalid_argument(e.what());
  } catch (...) {
    throw std::invalid_argument(
      "Function threw an unknown exception. Please file a bug at "
      "https://github.com/openxla/xla/issues with details on how to "
      "reproduce the error.");
  }
  if (result.ok()) {
    return *std::move(result);
  }
  throw std::invalid_argument(std::string(result.status().message()));
}

}  // namespace util
}  // namespace runtime
}  // namespace xla_launcher

#endif  // XLA_LAUNCHER_RUNTIME_XLA_UTIL_HPP_
